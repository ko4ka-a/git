#include <iostream> 
using namespace std;
int f(int a[100][100], int line, int column, int m)// Ввожу функцию, которая будет считать сумму элементов ниже главной диагонали матрицы. Для этого выделяю память для двумерного массива, для кол-ва строк, кол-ва столбцов и размерности массива
{
    int s = 0;
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if ((i >= 1) && (j >= 0) && (i - j > 0))// Решаю через индексы массива, поэтому замечаю, что элементы ниже главной диагонали по i-строки должно начинаться с 1, j-столбцы с 0 и должно выполняться неравенство номер строки-номер столбца больше 0, если будет равно 0, то это элемент главной диагонали, если меньше единицы, то это будет элемент выше главной диагонали
            {
                s += a[i][j];// Считается сумма элементов ниже главной диагонали
            }
        }
    }
    return s;// В этой функции возвращается сумма элементов
}
int main()
{
    setlocale(LC_ALL, "RU");
    int m,n;// Выделяю память для размерности матрицы-m и для кол-ва матриц-n
    cout << "Введите размерность матрицы" << endl;
    cin >> m;
    cout << "Введите количество матриц" << endl;
    cin >> n;
    int a[100][100];// Выделяю память для двумерного массива
    int max = 0;// Выделяю память для максимального элемента и приравниваю его к 0
    while (n > 0)// Использую цикл, чтобы считалась сумма для всех матриц
    {
        cout << endl;
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < m; j++)
            {
                a[i][j] = rand() % 101 - 50;// Заполняется массив рандомно положительными и отрицательными числами
                cout << a[i][j] << " ";// Вывод матрицы
            }
            cout << endl;
        }
        f(a, n, n, m);// Использую функцию, чтобы посчиталась сумма в данной матрице
        n--;// Уменьшается количество матриц
        cout << f(a, n, n, m);// Вывод суммы
        int ss = f(a, n, n, m);// Выделяется память для числа ss и приравнивается с суммой элементов для последующего сравнения
        if (max < ss)// Если ss будет больше,то max придаем значение ss, если меньше, с max ничего не происходит
        {
            max = ss;// Max равняется ss для послежующего сравнения
        }
    }
    cout << endl;
    cout << max;// Вывод максимальной суммы
    return 0;
}